atcommand.c:			if( bg->skill_block_timer[idx] == INVALID_TIMER )
atcommand.c:		if( (pl_sd = bg->members[i].sd) == NULL)
battleground.c:	if( idx < 0 || idx >= MAX_GUILDSKILL || !bg->g )
battleground.c:	return bg->g->skill[idx].lv;
battleground.c:	if( tid != bg->skill_block_timer[idx] )
battleground.c:		ShowError("bg_block_skill_end %d != %d.\n", bg->skill_block_timer[idx], tid);
battleground.c:	sprintf(output, "%s: Guild Skill %s Ready!!", bg->g->name, skill_get_desc((int)data));
battleground.c:	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
battleground.c:	bg->skill_block_timer[idx] = INVALID_TIMER;
battleground.c:	if( bg == NULL || bg->g == NULL || idx < 0 || idx >= MAX_GUILDSKILL || bg->skill_block_timer[idx] == INVALID_TIMER )
battleground.c:	if( (td = get_timer(bg->skill_block_timer[idx])) == NULL )
battleground.c:	sprintf(output, "%s : Cannot use team skill %s. %d seconds remaining...", bg->g->name, skill_get_desc(skillnum), seconds);
battleground.c:	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
battleground.c:	if( bg->skill_block_timer[idx] != INVALID_TIMER )
battleground.c:		delete_timer(bg->skill_block_timer[idx], bg_block_skill_end);
battleground.c:	bg->skill_block_timer[idx] = add_timer(gettick() + time, bg_block_skill_end, bg->bg_id, skillnum);
battleground.c:	ARR_FIND(0, MAX_BG_MEMBERS, i, bg->members[i].sd != NULL);
battleground.c:	return( i < MAX_BG_MEMBERS ) ? bg->members[i].sd : NULL;
battleground.c:	if(map[bg->mapindex].flag.bg_active)
battleground.c:		map[bg->mapindex].flag.bg_active = 0;
battleground.c:		if( (sd = bg->members[i].sd) == NULL )
battleground.c:		if( bg->skill_block_timer[i] == INVALID_TIMER )
battleground.c:		delete_timer(bg->skill_block_timer[i], bg_block_skill_end);
battleground.c:		bg->count =0;
battleground.c:		bg->leader_char_id =0;
battleground.c:		bg->team_score = 0;
battleground.c:		bg->creation_tick = 0;
battleground.c:		memset(&bg->members, 0, sizeof(bg->members));
battleground.c:		mapindex = bg->mapindex;
battleground.c:		x = bg->x;
battleground.c:		y = bg->y;
battleground.c:		if( bg->members[i].sd != NULL ) pc_setpos(bg->members[i].sd, mapindex, x, y, CLR_TELEPORT);
battleground.c:		if( bg->reveal_pos && (m = map_mapindex2mapid(bg->mapindex)) == sd->bl.m )
battleground.c:	ARR_FIND(0, MAX_BG_MEMBERS, i, bg->members[i].sd == NULL);
battleground.c:	bg->members[i].sd = sd;
battleground.c:	bg->members[i].x = sd->bl.x;
battleground.c:	bg->members[i].y = sd->bl.y;
battleground.c:	bg->count++;
battleground.c:	if( battle_config.bg_ranked_mode && sd->status.bg_stats.rank_games < battle_config.bg_ranked_max_games && DIFF_TICK(last_tick,bg->creation_tick) < 60 )
battleground.c:		bg->members[i].ranked = true;
battleground.c:	if( bg->leader_char_id == 0 )
battleground.c:		bg->leader_char_id = sd->status.char_id;
battleground.c:	// clif_bg_emblem(sd, bg->g);
battleground.c:		if( (pl_sd = bg->members[i].sd) == NULL )
battleground.c:		clif_bg_emblem(pl_sd, bg->g);
battleground.c:	ARR_FIND(0, MAX_BG_MEMBERS, i, bg->members[i].sd == sd);
battleground.c:		memset(&bg->members[i], 0, sizeof(bg->members[0]));
battleground.c:	if( bg->leader_char_id == sd->status.char_id )
battleground.c:		bg->leader_char_id = 0;
battleground.c:	bg->count--;
battleground.c:		if( (pl_sd = bg->members[i].sd) == NULL )
battleground.c:		if( !bg->leader_char_id && pl_sd->status.char_id)
battleground.c:			bg->leader_char_id = pl_sd->status.char_id;
battleground.c:		clif_bg_emblem(pl_sd, bg->g);
battleground.c:		case 3: sprintf(output, "%s: %s kicked by AFK Status.", bg->g->name, sd->status.name); break;
battleground.c:		case 2: sprintf(output, "%s: %s kicked by AFK Report.", bg->g->name, sd->status.name); break;
battleground.c:		case 1: sprintf(output, "%s: %s has quit the game.", bg->g->name, sd->status.name); break;
battleground.c:		case 0: sprintf(output, "%s: %s is leaving the battlefield.", bg->g->name, sd->status.name); break;
battleground.c: 	clif_bg_message(bg, 0, bg->g->name, output, strlen(output) + 1);
battleground.c:	if( bg->logout_event[0] && flag )
battleground.c:		npc_event(sd, bg->logout_event, 0);
battleground.c:	return bg->count;
battleground.c:	if( bg->mapindex == 0 )
battleground.c:	pc_setpos(sd, bg->mapindex, bg->x, bg->y, CLR_OUTSIGHT);
battleground.c:	return bg->g;
battleground.c:	bg->bg_id = bg_team_counter;
battleground.c:	bg->creation_tick = last_tick;
battleground.c:	bg->count = 0;
battleground.c:	bg->g = &bg_guild[guild_index];
battleground.c:	bg->mapindex = mapindex;
battleground.c:	bg->x = rx;
battleground.c:	bg->y = ry;
battleground.c:	safestrncpy(bg->logout_event, ev, sizeof(bg->logout_event));
battleground.c:	safestrncpy(bg->die_event, dev, sizeof(bg->die_event));
battleground.c:		bg->skill_block_timer[i] = INVALID_TIMER;
battleground.c:	memset(&bg->members, 0, sizeof(bg->members));
battleground.c:	bg->color = bg_colors[guild_index];
battleground.c:	return bg->bg_id;
battleground.c:	m = map_mapindex2mapid(bg->mapindex);
battleground.c:	bg->reveal_flag = !bg->reveal_flag; // Switch
battleground.c:		if( (sd = bg->members[i].sd) == NULL )
battleground.c:		if( sd->bl.x != bg->members[i].x || sd->bl.y != bg->members[i].y )
battleground.c:			bg->members[i].x = sd->bl.x;
battleground.c:			bg->members[i].y = sd->bl.y;
battleground.c:		if( bg->reveal_pos && bg->reveal_flag && sd->bl.m == m ) // Reveal each 4 seconds
battleground.c:			map_foreachinmap(bg_reveal_pos,m,BL_PC,sd,1,bg->color);
battleground.c:		if( battle_config.bg_idle_autokick && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_autokick && bg->g )
battleground.c:			clif_bg_message(bg, bg->bg_id, bg->g->name, output, (int)strlen(output) + 1);
battleground.c:/*		if( battle_config.bg_idle_announce && !sd->state.bg_afk && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_announce && bg->g )
battleground.c:			//sprintf(output, "%s : %s seems to be away! Will be kicked out", bg->g->name, sd->status.name);
battleground.c:			//clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
battleground.c:		if( (sd = bg->members[i].sd) == NULL )
battleground.c:		if( (sd = bg->members[i].sd) == NULL )
battleground.c:		if( (sd = bg->members[i].sd) == NULL )
battleground.c:		type = bg->members[i].ranked ? 1 : 2; // Where to Add Fame
battleground.c:	bg_team_clean(bg->bg_id,false);
clif.c:				if( (sd = bg->members[i].sd) == NULL || !(fd = sd->fd) )
clif.c:	WFIFOL(fd,10)=bg?bg->count:g->connect_member;
clif.c:				if( bg->skill_block_timer[idx] == INVALID_TIMER )
clif.c:	else if( md->state.bg_id && (bg = bg_team_search(md->state.bg_id)) != NULL && (g = bg->g) != NULL )
clif.c:	if( (m = map_mapindex2mapid(bg->mapindex)) < 0 )
clif.c:	WBUFL(buf,10) = bg->team_score;
clif.c:		if( (sd = bg->members[i].sd) == NULL || sd->bl.m != m )
clif.c:	if( (bg_id = bg_team_get_id(bl)) > 0 && (bg = bg_team_search(bg_id)) != NULL && bg->g )
clif.c:		return bg->g->guild_id;
clif.c:	else if( (bg_id = bg_team_get_id(bl)) > 0 && (bg = bg_team_search(bg_id)) != NULL && bg->g )
clif.c:		return bg->g->emblem_id;
clif.c:	WFIFOHEAD(fd,bg->count * 104 + 4);
clif.c:	for( i = 0, c = 0; i < bg->count; i++ )
clif.c:		if( (psd = bg->members[i].sd) == NULL )
clif.c:		WFIFOL(fd,10) = bg->team_score;
party.c:			if( (psd = bg->members[i].sd) == NULL )
pc.c:		ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
pc.c:		type = bg->members[i].ranked ? 1 : 2;
pc.c:		ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
pc.c:		type = bg->members[i].ranked ? 1 : 2;
pc.c:		ARR_FIND(0,MAX_BG_MEMBERS,i,s_bg->members[i].sd == ssd);
pc.c:		type = s_bg->members[i].ranked ? 1 : 2;
pc.c://	if( sd->state.bg_id && sd->state.bg_afk && (bg = bg_team_search(sd->state.bg_id)) != NULL && bg->g )
pc.c://		sprintf(output, "%s: %s is no longer away", bg->g->name, sd->status.name);
pc.c:	//	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
pc.c:		if( count_bg_stats(sd->bl.m) && (bg = bg_team_search(sd->state.bg_id)) != NULL && bg->die_event[0] )
pc.c:			npc_event(sd, bg->die_event, 0);
pc.c:		if( bg && bg->mapindex > 0 )
raid.c:/*		if( battle_config.bg_idle_announce && !sd->state.bg_afk && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_announce && bg->g )
raid.c:			sprintf(output, "%s : %s seems to be away! A Can be kicked out by Team Leader with @reportafk", bg->g->name, sd->status.name);
raid.c:			clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
script.c:		if( bg->count < min )
script.c:			min = bg->count;
script.c:		if( (bg = bg_team_search(m_bg_id)) != NULL && bg->mapindex )
script.c:			pc_setpos(sd,bg->mapindex,bg->x,bg->y,CLR_OUTSIGHT); // Joins and Warps
script.c:			if( bg->count < min )
script.c:				min = bg->count;
script.c:	bg->x = script_getnum(st,3);
script.c:	bg->y = script_getnum(st,4);
script.c:	bg->reveal_pos = true; // Reveal Position Mode
script.c:		if( (sd = bg->members[i].sd) == NULL )
script.c:		if( (sd = bg->members[i].sd) == NULL )
script.c:		bg->team_score = score;
script.c:	if( (bg = bg_team_search(bg_id)) != NULL && bg->g )
script.c:		guild_id = bg->g->guild_id;
script.c:		case 0: script_pushint(st, bg->count); break;
script.c:				for( i = 0; i < bg->count; i++ )
script.c:					if( (sd = bg->members[i].sd) == NULL )
script.c:	ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
script.c:	flag = bg->members[i].ranked ? 2 : 3;
script.c:		if( (sd = bg->members[i].sd) == NULL )
script.c:		if( (bg_sd = bg->members[i].sd) == NULL )
skill.c:					ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
skill.c:					type = bg->members[i].ranked ? 1 : 2;
skill.c:					if( (dstsd = bg->members[i].sd) == NULL || sd == dstsd || pc_isdead(dstsd) )
